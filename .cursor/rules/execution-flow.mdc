---
description: 
globs: 
alwaysApply: true
---
# Flusso di Esecuzione per Assistenti AI

Questo documento definisce la sequenza specifica di passi che un assistente AI deve seguire quando analizza un problema e propone una soluzione. Seguendo questo flusso standardizzato, si garantisce coerenza negli approcci e si minimizzano gli errori.

## üîÑ Ciclo di Esecuzione Completo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  1. COMPRENSIONE    ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  2. RICOGNIZIONE    ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  3. ANALISI         ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  4. PIANIFICAZIONE  ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  5. IMPLEMENTAZIONE ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ‚îÇ
‚îÇ  6. VERIFICA        ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 1Ô∏è‚É£ FASE DI COMPRENSIONE

**Obiettivo**: Comprendere esattamente il problema o l'esigenza dell'utente.

### Passi Obbligatori

1. **Identifica il tipo di richiesta**:
   - Correzione bug?
   - Nuova funzionalit√†?
   - Miglioramento?
   - Chiarimento?

2. **Definisci l'ambito del problema**:
   - Quali parti del sistema sono coinvolte?
   - Quali entit√†/relazioni sono interessate?
   - Quali utenti/casi d'uso sono impattati?

3. **Valuta la criticit√†**:
   - √à un problema bloccante?
   - Influisce su funzionalit√† critiche?
   - Ha implicazioni per la sicurezza o l'integrit√† dei dati?

4. **Chiarisci eventuali ambiguit√†**:
   - Se la richiesta non √® chiara, chiedi precisazioni
   - Assicurati di comprendere le aspettative dell'utente

### Output della Fase

- **Definizione chiara del problema**: "Il problema consiste in... e influisce su..."
- **Ambito definito**: "Le componenti coinvolte sono..."
- **Criticit√† identificata**: "Si tratta di un problema di priorit√†..."

## 2Ô∏è‚É£ FASE DI RICOGNIZIONE

**Obiettivo**: Identificare tutte le componenti rilevanti esistenti nel sistema.

### Passi Obbligatori

1. **Esplora la struttura delle directory**:
   - Identifica i file/directory pertinenti al problema
   - Mappa la struttura interessata

2. **Identifica componenti esistenti**:
   - Consulta [Name Recognition](mdc:name-recognition.mdc)
   - Cerca componenti, hook, servizi esistenti relativi al problema
   - Individua implementazioni simili in altre parti del sistema

3. **Analizza relazioni e dipendenze**:
   - Identifica relazioni tra le entit√† coinvolte
   - Controlla le dipendenze tra i componenti

4. **Riconosci pattern esistenti**:
   - Identifica pattern di implementazione
   - Osserva la gestione di casi simili nel sistema

### Output della Fase

- **Mappa dei file rilevanti**: "I file coinvolti sono..."
- **Componenti esistenti identificati**: "Esistono gi√† i seguenti componenti pertinenti..."
- **Pattern riconosciuti**: "Il pattern utilizzato per casi simili √®..."

## 3Ô∏è‚É£ FASE DI ANALISI

**Obiettivo**: Analizzare a fondo il problema e valutare le possibili soluzioni.

### Passi Obbligatori

1. **Analizza la causa principale**:
   - Identifica la causa radice del problema
   - Verifica se esistono segnalazioni simili in altre parti del sistema

2. **Esamina il codice esistente**:
   - Analizza l'implementazione attuale
   - Identifica potenziali punti deboli o bug

3. **Considera vincoli e limitazioni**:
   - Architettura esistente
   - Convenzioni di nomenclatura
   - Relazioni tra entit√†
   - Requisiti di prestazioni

4. **Genera opzioni di soluzione**:
   - Identifica 2-3 approcci possibili
   - Considera soluzioni minimali vs rifattorizzazioni pi√π ampie

5. **Valuta pro e contro**:
   - Per ogni soluzione, valuta:
     - Complessit√†
     - Impatto
     - Compatibilit√† con struttura esistente
     - Sostenibilit√† a lungo termine

### Output della Fase

- **Causa identificata**: "Il problema √® causato da..."
- **Opzioni di soluzione**: "Le possibili soluzioni sono..."
- **Analisi pro/contro**: "Ciascuna soluzione presenta i seguenti vantaggi/svantaggi..."

## 4Ô∏è‚É£ FASE DI PIANIFICAZIONE

**Obiettivo**: Pianificare in dettaglio l'implementazione della soluzione scelta.

### Passi Obbligatori

1. **Seleziona la soluzione ottimale**:
   - Scegli l'approccio pi√π adatto considerando:
     - Compatibilit√† con l'architettura esistente
     - Minimo impatto (principio di modifica chirurgica)
     - Efficacia nel risolvere il problema
     - Sostenibilit√† a lungo termine

2. **Identifica i file da modificare**:
   - Elenca esattamente quali file devono essere modificati
   - Valuta se √® necessario creare nuovi file (evitare se possibile)

3. **Pianifica l'implementazione in step**:
   - Dividi la soluzione in passaggi logici
   - Definisci l'ordine di esecuzione

4. **Prevedi potenziali problemi**:
   - Identifica possibili effetti collaterali
   - Considera casi limite e gestione errori

### Output della Fase

- **Soluzione selezionata**: "La soluzione ottimale √®..."
- **Elenco modifiche**: "I seguenti file verranno modificati: ..."
- **Piano di implementazione**: "L'implementazione seguir√† questi passi: ..."
- **Considerazioni di rischio**: "Saranno gestiti i seguenti rischi: ..."

## 5Ô∏è‚É£ FASE DI IMPLEMENTAZIONE

**Obiettivo**: Implementare la soluzione seguendo il piano definito.

### Passi Obbligatori

1. **Segui esattamente il piano definito**:
   - Attieniti ai passi pianificati
   - Non introdurre modifiche non previste

2. **Modifica chirurgicamente**:
   - Limita le modifiche all'essenziale
   - Non alterare comportamenti esistenti funzionanti

3. **Segui convenzioni e pattern**:
   - Mantieni coerenza con il codice esistente
   - Segui convenzioni di nomenclatura
   - Utilizza pattern consolidati

4. **Documenta adeguatamente**:
   - Aggiungi commenti JSDoc
   - Spiega parti complesse con commenti inline
   - Aggiorna documentazione se necessario

5. **Gestisci errori e casi limite**:
   - Implementa gestione errori robusta
   - Considera tutti i casi limite
   - Usa l'hook `useErrorHandler` per gestire errori API

### Output della Fase

- **Codice implementato**: Le modifiche effettive al codice
- **Documentazione aggiornata**: Commenti JSDoc e spiegazioni

## 6Ô∏è‚É£ FASE DI VERIFICA

**Obiettivo**: Verificare che la soluzione implementata risolva il problema e non ne introduca di nuovi.

### Passi Obbligatori

1. **Verifica tramite checklist**:
   - Consulta [Verification Checklist](mdc:verification-checklist.mdc)
   - Valida punto per punto

2. **Controlla anti-pattern**:
   - Consulta [Anti-Patterns](mdc:anti-patterns.mdc)
   - Assicurati di non aver introdotto anti-pattern

3. **Verifica completezza**:
   - La soluzione risolve completamente il problema?
   - Sono stati considerati tutti i casi d'uso?

4. **Controlla effetti collaterali**:
   - La soluzione impatta altri componenti?
   - Sono stati gestiti tutti gli effetti secondari?

5. **Valida coerenza architetturale**:
   - La soluzione rispetta l'architettura del sistema?
   - Sono stati seguiti i pattern esistenti?

### Output della Fase

- **Risultato della verifica**: "La soluzione √® stata verificata con..."
- **Conferma di completezza**: "La soluzione risolve il problema perch√©..."
- **Validazione architetturale**: "La soluzione √® coerente con l'architettura perch√©..."

## üìä Esempio di Flusso Completo

### Scenario: Bug nella visualizzazione dei dettagli di un dipendente

#### 1. COMPRENSIONE
- **Tipo di richiesta**: Correzione bug
- **Ambito**: Visualizzazione dettagli dipendente
- **Criticit√†**: Media (non blocca l'uso del sistema ma limita la funzionalit√†)
- **Definizione del problema**: "I dettagli del dipendente non vengono visualizzati quando l'utente clicca su un elemento nella lista dipendenti"

#### 2. RICOGNIZIONE
- **File coinvolti**:
  - `src/components/employees/EmployeeList.tsx`
  - `src/components/employees/EmployeeDetails.tsx`
  - `src/services/employees.ts`
- **Componenti esistenti**:
  - Lista dipendenti
  - Componente dettagli dipendente
  - Servizio API dipendenti
- **Pattern riconosciuti**:
  - Pattern container/presentational per gestione stato
  - Factory pattern per i servizi API

#### 3. ANALISI
- **Causa principale**: Il componente EmployeeDetails non riceve correttamente l'ID del dipendente selezionato
- **Opzioni di soluzione**:
  1. Fix minimo: Correggere il passaggio dell'ID nel componente EmployeeList
  2. Soluzione pi√π robusta: Implementare gestione stato con Context API
- **Analisi pro/contro**:
  - Fix minimo: Semplice, non invasivo, ma potrebbe non coprire tutti i casi
  - Soluzione Context: Pi√π robusta ma richiede pi√π modifiche

#### 4. PIANIFICAZIONE
- **Soluzione selezionata**: Fix minimo (approccio chirurgico)
- **File da modificare**: `src/components/employees/EmployeeList.tsx`
- **Piano implementazione**:
  1. Identificare dove viene gestito il click sull'elemento della lista
  2. Correggere il passaggio dell'ID
  3. Verificare la propagazione corretta dell'evento

#### 5. IMPLEMENTAZIONE
```jsx
// Modifica in EmployeeList.tsx
// Da:
const handleEmployeeClick = (employee) => {
  onEmployeeSelect(employee);
};

// A:
const handleEmployeeClick = (employee) => {
  onEmployeeSelect(employee.id); // Passa l'ID invece dell'oggetto completo
};
```

#### 6. VERIFICA
- **Checklist**: Tutte le voci verificate
- **Completezza**: La modifica risolve il problema passando correttamente l'ID
- **Effetti collaterali**: Nessuno identificato
- **Coerenza architetturale**: Mantiene lo stesso pattern esistente

## üö¶ Regole di Interruzione del Flusso

Interrompi il flusso e chiedi chiarimenti all'utente se:

1. **Comprensione incompleta**:
   - La richiesta √® ambigua
   - Mancano informazioni essenziali per procedere

2. **Conflitto con regole critiche**:
   - La soluzione richiederebbe violazione di regole architetturali
   - Sarebbe necessario modificare server o porte

3. **Rischio elevato**:
   - La modifica potrebbe avere impatti profondi non valutabili
   - La soluzione coinvolge aree critiche del sistema

4. **Alternativa strategica**:
   - Hai identificato un approccio radicalmente diverso che potrebbe essere migliore
   - Esistono multiple soluzioni con compromessi significativi

## üß† Considerazioni sulla Risoluzione dei Problemi

### 1. Preferisci sempre modifiche minimali

Segui il principio di "chirurgia minima": modifica solo ci√≤ che √® necessario per risolvere il problema, evitando cambiamenti pi√π ampi di quanto richiesto.

### 2. Evita creazione non necessaria di file

Verifica sempre se √® possibile risolvere il problema estendendo componenti esistenti prima di creare nuovi file.

### 3. Riutilizza pattern esistenti

Se un pattern √® gi√† implementato nel sistema (es. per gestione errori, CRUD, ecc.), utilizzalo anche nella tua soluzione.

### 4. Mantieni coerenza di nomenclatura e stile

Assicurati che le tue modifiche seguano le stesse convenzioni utilizzate nel resto del progetto.

### 5. Rispondi con la massima specificit√† possibile

Quando proponi una soluzione, sii preciso nei dettagli implementativi e nelle giustificazioni.
